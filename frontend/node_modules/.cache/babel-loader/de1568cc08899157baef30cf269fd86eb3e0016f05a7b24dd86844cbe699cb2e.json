{"ast":null,"code":"import * as StellarSdk from '@stellar/stellar-sdk';\nimport { signTransaction } from '@stellar/freighter-api';\n\n// Stellar testnet configuration\nconst HORIZON_URL = 'https://horizon-testnet.stellar.org';\nconst NETWORK_PASSPHRASE = StellarSdk.Networks.TESTNET;\nconst server = new StellarSdk.Horizon.Server(HORIZON_URL);\n\n/**\n * Build a payment transaction from source to destination\n * @param sourcePublicKey - The sender's public key\n * @param destinationPublicKey - The recipient's public key\n * @param amount - Amount of XLM to send\n * @param memo - Optional memo text\n * @returns Transaction XDR string ready for signing\n */\nexport async function buildPaymentTransaction(sourcePublicKey, destinationPublicKey, amount, memo) {\n  try {\n    // Load the source account\n    const sourceAccount = await server.loadAccount(sourcePublicKey);\n\n    // Build the transaction\n    const transaction = new StellarSdk.TransactionBuilder(sourceAccount, {\n      fee: StellarSdk.BASE_FEE,\n      networkPassphrase: NETWORK_PASSPHRASE\n    }).addOperation(StellarSdk.Operation.payment({\n      destination: destinationPublicKey,\n      asset: StellarSdk.Asset.native(),\n      // XLM\n      amount: amount\n    })).setTimeout(180); // 3 minutes timeout\n\n    // Add memo if provided\n    if (memo) {\n      transaction.addMemo(StellarSdk.Memo.text(memo));\n    }\n    const builtTransaction = transaction.build();\n    return builtTransaction.toXDR();\n  } catch (error) {\n    console.error('Error building transaction:', error);\n    throw new Error(`Failed to build transaction: ${error.message}`);\n  }\n}\n\n/**\n * Sign a transaction using Freighter wallet\n * @param transactionXDR - The transaction XDR to sign\n * @param publicKey - The public key of the signer\n * @returns Signed transaction XDR\n */\nexport async function signTransactionWithFreighter(transactionXDR, publicKey) {\n  try {\n    const {\n      signedTxXdr,\n      error\n    } = await signTransaction(transactionXDR, {\n      networkPassphrase: NETWORK_PASSPHRASE,\n      address: publicKey\n    });\n    if (error) {\n      throw new Error(error);\n    }\n    if (!signedTxXdr) {\n      throw new Error('No signed transaction returned from Freighter');\n    }\n    return signedTxXdr;\n  } catch (error) {\n    console.error('Error signing transaction:', error);\n    throw new Error(`Failed to sign transaction: ${error.message}`);\n  }\n}\n\n/**\n * Submit a signed transaction to the Stellar network\n * @param signedXDR - The signed transaction XDR\n * @returns Transaction result including hash\n */\nexport async function submitSignedTransaction(signedXDR) {\n  try {\n    const transaction = StellarSdk.TransactionBuilder.fromXDR(signedXDR, NETWORK_PASSPHRASE);\n    const result = await server.submitTransaction(transaction);\n    return {\n      hash: result.hash,\n      ledger: result.ledger,\n      successful: result.successful\n    };\n  } catch (error) {\n    var _error$response, _error$response$data, _error$response$data$;\n    console.error('Error submitting transaction:', error);\n\n    // Stellar-specific error handling\n    if ((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && (_error$response$data$ = _error$response$data.extras) !== null && _error$response$data$ !== void 0 && _error$response$data$.result_codes) {\n      const resultCodes = error.response.data.extras.result_codes;\n      throw new Error(`Transaction failed: ${resultCodes.transaction} - ${JSON.stringify(resultCodes.operations)}`);\n    }\n    throw new Error(`Failed to submit transaction: ${error.message}`);\n  }\n}\n\n/**\n * Complete payment flow: build, sign, and submit transaction\n * @param sourcePublicKey - Sender's wallet address\n * @param destinationPublicKey - Recipient's wallet address\n * @param amount - Amount of XLM\n * @param memo - Optional memo\n * @returns Transaction hash\n */\nexport async function executePayment(sourcePublicKey, destinationPublicKey, amount, memo) {\n  try {\n    // Step 1: Build transaction\n    console.log('Building payment transaction...');\n    const transactionXDR = await buildPaymentTransaction(sourcePublicKey, destinationPublicKey, amount, memo);\n\n    // Step 2: Sign with Freighter\n    console.log('Requesting signature from Freighter...');\n    const signedXDR = await signTransactionWithFreighter(transactionXDR, sourcePublicKey);\n\n    // Step 3: Submit to network\n    console.log('Submitting transaction to Stellar network...');\n    const result = await submitSignedTransaction(signedXDR);\n    if (!result.successful) {\n      throw new Error('Transaction was not successful');\n    }\n    console.log('Transaction successful! Hash:', result.hash);\n    return result.hash;\n  } catch (error) {\n    console.error('Payment execution failed:', error);\n    throw error;\n  }\n}\n\n/**\n * Verify a transaction on the Stellar network\n * @param transactionHash - The transaction hash to verify\n * @returns Transaction details if found\n */\nexport async function verifyTransaction(transactionHash) {\n  try {\n    const transaction = await server.transactions().transaction(transactionHash).call();\n    return transaction;\n  } catch (error) {\n    console.error('Error verifying transaction:', error);\n    throw new Error(`Failed to verify transaction: ${error.message}`);\n  }\n}","map":{"version":3,"names":["StellarSdk","signTransaction","HORIZON_URL","NETWORK_PASSPHRASE","Networks","TESTNET","server","Horizon","Server","buildPaymentTransaction","sourcePublicKey","destinationPublicKey","amount","memo","sourceAccount","loadAccount","transaction","TransactionBuilder","fee","BASE_FEE","networkPassphrase","addOperation","Operation","payment","destination","asset","Asset","native","setTimeout","addMemo","Memo","text","builtTransaction","build","toXDR","error","console","Error","message","signTransactionWithFreighter","transactionXDR","publicKey","signedTxXdr","address","submitSignedTransaction","signedXDR","fromXDR","result","submitTransaction","hash","ledger","successful","_error$response","_error$response$data","_error$response$data$","response","data","extras","result_codes","resultCodes","JSON","stringify","operations","executePayment","log","verifyTransaction","transactionHash","transactions","call"],"sources":["C:/Users/debja/Desktop/FairDeal-main/FairDeal-main/frontend/src/utils/stellar-utils.ts"],"sourcesContent":["import * as StellarSdk from '@stellar/stellar-sdk';\nimport { signTransaction } from '@stellar/freighter-api';\n\n// Stellar testnet configuration\nconst HORIZON_URL = 'https://horizon-testnet.stellar.org';\nconst NETWORK_PASSPHRASE = StellarSdk.Networks.TESTNET;\n\nconst server = new StellarSdk.Horizon.Server(HORIZON_URL);\n\n/**\n * Build a payment transaction from source to destination\n * @param sourcePublicKey - The sender's public key\n * @param destinationPublicKey - The recipient's public key\n * @param amount - Amount of XLM to send\n * @param memo - Optional memo text\n * @returns Transaction XDR string ready for signing\n */\nexport async function buildPaymentTransaction(\n    sourcePublicKey: string,\n    destinationPublicKey: string,\n    amount: string,\n    memo?: string\n): Promise<string> {\n    try {\n        // Load the source account\n        const sourceAccount = await server.loadAccount(sourcePublicKey);\n\n        // Build the transaction\n        const transaction = new StellarSdk.TransactionBuilder(sourceAccount, {\n            fee: StellarSdk.BASE_FEE,\n            networkPassphrase: NETWORK_PASSPHRASE,\n        })\n            .addOperation(\n                StellarSdk.Operation.payment({\n                    destination: destinationPublicKey,\n                    asset: StellarSdk.Asset.native(), // XLM\n                    amount: amount,\n                })\n            )\n            .setTimeout(180); // 3 minutes timeout\n\n        // Add memo if provided\n        if (memo) {\n            transaction.addMemo(StellarSdk.Memo.text(memo));\n        }\n\n        const builtTransaction = transaction.build();\n        return builtTransaction.toXDR();\n    } catch (error: any) {\n        console.error('Error building transaction:', error);\n        throw new Error(`Failed to build transaction: ${error.message}`);\n    }\n}\n\n/**\n * Sign a transaction using Freighter wallet\n * @param transactionXDR - The transaction XDR to sign\n * @param publicKey - The public key of the signer\n * @returns Signed transaction XDR\n */\nexport async function signTransactionWithFreighter(\n    transactionXDR: string,\n    publicKey: string\n): Promise<string> {\n    try {\n        const { signedTxXdr, error } = await signTransaction(transactionXDR, {\n            networkPassphrase: NETWORK_PASSPHRASE,\n            address: publicKey,\n        });\n\n        if (error) {\n            throw new Error(error);\n        }\n\n        if (!signedTxXdr) {\n            throw new Error('No signed transaction returned from Freighter');\n        }\n\n        return signedTxXdr;\n    } catch (error: any) {\n        console.error('Error signing transaction:', error);\n        throw new Error(`Failed to sign transaction: ${error.message}`);\n    }\n}\n\n/**\n * Submit a signed transaction to the Stellar network\n * @param signedXDR - The signed transaction XDR\n * @returns Transaction result including hash\n */\nexport async function submitSignedTransaction(signedXDR: string): Promise<{\n    hash: string;\n    ledger: number;\n    successful: boolean;\n}> {\n    try {\n        const transaction = StellarSdk.TransactionBuilder.fromXDR(signedXDR, NETWORK_PASSPHRASE);\n\n        const result = await server.submitTransaction(transaction);\n\n        return {\n            hash: result.hash,\n            ledger: result.ledger,\n            successful: result.successful,\n        };\n    } catch (error: any) {\n        console.error('Error submitting transaction:', error);\n\n        // Stellar-specific error handling\n        if (error.response?.data?.extras?.result_codes) {\n            const resultCodes = error.response.data.extras.result_codes;\n            throw new Error(\n                `Transaction failed: ${resultCodes.transaction} - ${JSON.stringify(resultCodes.operations)}`\n            );\n        }\n\n        throw new Error(`Failed to submit transaction: ${error.message}`);\n    }\n}\n\n/**\n * Complete payment flow: build, sign, and submit transaction\n * @param sourcePublicKey - Sender's wallet address\n * @param destinationPublicKey - Recipient's wallet address\n * @param amount - Amount of XLM\n * @param memo - Optional memo\n * @returns Transaction hash\n */\nexport async function executePayment(\n    sourcePublicKey: string,\n    destinationPublicKey: string,\n    amount: string,\n    memo?: string\n): Promise<string> {\n    try {\n        // Step 1: Build transaction\n        console.log('Building payment transaction...');\n        const transactionXDR = await buildPaymentTransaction(\n            sourcePublicKey,\n            destinationPublicKey,\n            amount,\n            memo\n        );\n\n        // Step 2: Sign with Freighter\n        console.log('Requesting signature from Freighter...');\n        const signedXDR = await signTransactionWithFreighter(transactionXDR, sourcePublicKey);\n\n        // Step 3: Submit to network\n        console.log('Submitting transaction to Stellar network...');\n        const result = await submitSignedTransaction(signedXDR);\n\n        if (!result.successful) {\n            throw new Error('Transaction was not successful');\n        }\n\n        console.log('Transaction successful! Hash:', result.hash);\n        return result.hash;\n    } catch (error: any) {\n        console.error('Payment execution failed:', error);\n        throw error;\n    }\n}\n\n/**\n * Verify a transaction on the Stellar network\n * @param transactionHash - The transaction hash to verify\n * @returns Transaction details if found\n */\nexport async function verifyTransaction(transactionHash: string): Promise<any> {\n    try {\n        const transaction = await server.transactions().transaction(transactionHash).call();\n        return transaction;\n    } catch (error: any) {\n        console.error('Error verifying transaction:', error);\n        throw new Error(`Failed to verify transaction: ${error.message}`);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}